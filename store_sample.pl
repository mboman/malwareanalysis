#!/usr/bin/perl

# Stop us from shooting outselves in the foot
use strict;
use warnings;

# We are storing the configuration file in INI format
use Config::IniHash;

# We need to parse emails
use Email::Simple;
use Email::MIME::Attachment::Stripper;
use Date::Format;
use DateTime::Format::Mail;

# We need to calculate checksums
use Digest::SHA256;
use Digest::SHA1 qw( sha1_hex );
use Digest::MD5::File qw( file_md5_hex );

# We need to handle compression
use Archive::Zip;
use File::Temp qw( tempdir );
use File::Magic;
use File::Spec;
use File::Basename;

# We need to interact with Amazon S3
use Net::Amazon::S3;
use Net::Amazon::S3::Bucket;

# We need to interact with Amazon SimpleDB
use Amazon::SimpleDB::Client;

# We need to interact with MediaWiki
use CMS::MediaWiki;

# We need to interact with Amazon SQS
use Amazon::SQS::Simple;

# Local sub routines
sub dump_meta;
sub extract_archive_rar;
sub extract_archive_zip;
sub file_to_string;
sub my_filetype;
sub my_md5_hex;
sub my_sha1_hex;
sub my_sha256_hex;
sub process_file;
sub rand_string;
sub store_sample;
sub string_to_file;
sub system_unrar;
sub system_unzip;
sub update_wiki;

# BEGIN

# Configuration
my $config = ReadINI("config.ini");

print "DEBUG: Read configuration file\n";

# Our variables..
my %metadata = ();
my $response;
my $raw_input;

# Setup the environment
$metadata{'rcvd_DateTime'} = DateTime->now();

############################
# Setup the S3 environment #
############################

my $s3 = Net::Amazon::S3->new(
    aws_access_key_id     => $config->{'settings'}->{'aws_access_key_id'},
    aws_secret_access_key => $config->{'settings'}->{'aws_secret_access_key'},
    retry                 => 1
);

my $bucket = $s3->bucket( $config->{'settings'}->{'bucketname'} );

##################################
# Setup the SimpleDB environment #
##################################

my $simpledb = Amazon::SimpleDB::Client->new(
    $config->{'settings'}->{'aws_access_key_id'},
    $config->{'settings'}->{'aws_secret_access_key'}
);

$response = $simpledb->createDomain(
    { DomainName => $config->{'settings'}->{'simpledb_name'} } );

# Concatinate the input to a single string
while (<STDIN>) {
    $raw_input = $raw_input . $_;
}

my $email    = Email::Simple->new($raw_input);
my $stripper = Email::MIME::Attachment::Stripper->new($raw_input);

# Extract the header metadata
$metadata{'From'} = $email->header("From");
$metadata{'sent_DateTime'} =
  DateTime::Format::Mail->parse_datetime( $email->header("Date") );

# Convert the timestamps to GMT timezone
$metadata{'sent_DateTime'}->set_time_zone("GMT");
$metadata{'rcvd_DateTime'}->set_time_zone("GMT");

$metadata{'bucketpath'} = $metadata{'sent_DateTime'}->ymd("/");

# Extract the attachments
my $dir               = tempdir( CLEANUP => 1 );
my @attachments       = $stripper->attachments;
my $no_of_attachments = scalar(@attachments);

# For each attachment in the email...
for ( my $count = 0 ; $count < $no_of_attachments ; $count++ ) {

    # Generate file location
    my $filename =
      File::Spec->catfile( $dir, $attachments[$count]{'filename'} );

    # Store the attachement in a file
    string_to_file( $filename, $attachments[$count]{'payload'} );

    # Process the file
    process_file($filename);
}
print "Processed all the attachments\n\n";
exit;    # END OF PROGRAM

sub my_filetype {
    my $filename = shift or die("FUNCTION USAGE: my_filetype( filename );\n");

    print "DEBUG: my_filetype( " . $filename . " );\n";

    my $magic    = File::Magic->new();
    my $filetype = $magic->type($filename);
    return $filetype;
}

# Process the file
sub process_file {
    my $filename = shift
      or die("FUNCTION USAGE: process_file( filename );\n");

    print "DEBUG: process_file( " . $filename . " );\n";

    my $filetype = my_filetype($filename);

    # What kind of content do we have?
    for ($filetype) {
        if (/executable/) {
            store_sample($filename);
        }
        elsif (/Zip/) {
            extract_archive_zip($filename);
        }
        elsif (/RAR/) {
            extract_archive_rar($filename);
        }
        elsif ( $filename =~ m/\.com$/i ) {
            store_sample($filename);
        }
        else {
            print "DEBUG: Unknown filetype: " . $filetype . "\n";
            print "DEBUG: Need to send sample for manual analysis!\n";
        }
    }
}

sub dump_meta {
    #####################
    # "Debugging" tools #
    #####################
    print "DEBUG: dump_meta();\n";

    print "\nvvvv DUMP OF METADATA vvvvv\n";
    for my $key ( keys %metadata ) {
        my $value = $metadata{$key};
        print "$key => $value\n";
    }
    print "^^^^ DUMP OF METADATA ^^^^^\n\n";
}

#######################
# Extract the archive #
#######################
sub extract_archive_zip {
    my $filename = shift
      or die("FUNCTION USAGE: extract_archive_zip( filename );\n");
    my $tmpdir = tempdir( CLEANUP => 1 );
    print "DEBUG: extract_archive_zip( " . $filename . " );\n";

    my ( $error, $dir, @flist ) = system_unzip($filename);
    my $no_of_files = scalar(@flist);

    # For each attachment in the email...
    for ( my $count = 0 ; $count < $no_of_files ; $count++ ) {
        my $file = File::Spec->catfile( $dir, $flist[$count] );
        process_file($file);
    }
}

#######################
# Extract the archive #
#######################
sub extract_archive_rar {
    my $filename = shift
      or die("FUNCTION USAGE: extract_archive_rar( filename );\n");
    my $tmpdir = tempdir( CLEANUP => 1 );
    print "DEBUG: extract_archive_rar( " . $filename . " );\n";

    my ( $error, $dir, @flist ) = system_unrar($filename);
    my $no_of_files = scalar(@flist);

    # For each attachment in the email...
    for ( my $count = 0 ; $count < $no_of_files ; $count++ ) {
        my $file = File::Spec->catfile( $dir, $flist[$count] );
        process_file($file);
    }
}

########################################################
# Helper function. Writes file using string as content #
########################################################
sub string_to_file {
    my ( $filename, $data ) = @_;

    print "DEBUG: string_to_file( " . $filename . " );\n";

    open( OUTFILE, ">$filename" );
    print OUTFILE $data;
    close(OUTFILE);
}

###########################################
# Helper function. Reads file into string #
###########################################
sub file_to_string {
    my $filename = shift
      or die("FUNCTION USAGE: file_to_string( filename );\n");
    my $string;

    print "DEBUG: file_to_string( " . $filename . " );\n";

    open( INFILE, "<$filename" );
    while (<INFILE>) {
        $string = $string . $_;
    }
    close(INFILE);
    return $string;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub my_sha256_hex {
    my $filename = shift or die("FUNCTION USAGE: my_sha256_hex( filename );\n");

    my $sha256 = Digest::SHA256::new("256");

    print "DEBUG: my_sha256_hex( " . $filename . " );\n";

    $sha256->reset();
    $sha256->addfile($filename);
    my $result = $sha256->hexdigest();    # Calculate SHA256 checksum
    $result =~ s/\ //g;    # Remove the spaces from the SHA256 checksum

    return $result;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub my_md5_hex {
    my $filename = shift or die("FUNCTION USAGE: my_md5_hex( filename );\n");

    print "DEBUG: my_md5_hex( " . $filename . " );\n";
    my $result = file_md5_hex($filename);
    return $result;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub my_sha1_hex {
    my $filename = shift or die("FUNCTION USAGE: my_sha1_hex( filename );\n");

    print "DEBUG: my_sha1_hex( " . $filename . " );\n";
    my $result = sha1_hex( file_to_string($filename) );
    return $result;
}

#################################################
# Save the Sample to S3 and record the metadata #
#################################################
sub store_sample {
    my $filename = shift or die("FUNCTION USAGE: store_sample( filename );\n");

    print "DEBUG: store_sample( " . $filename . " );\n";

    $metadata{'original_filename'} = basename($filename);

    ########################
    # Checksum the payload #
    ########################

    $metadata{'sha256'} = my_sha256_hex($filename);  # Calculate SHA256 checksum
    $metadata{'sha1'}   = my_sha1_hex($filename);    # Calculate SHA1 checksum
    $metadata{'md5'}    = my_md5_hex($filename);     # Calculate MD5 checksum

    ########################
    # Create a ZIP archive #
    ########################

    # Define the filename of the ZIP archive
    $metadata{'zipname'} = $metadata{'sha256'} . ".zip";

    # Zip the payload
    my $zip = Archive::Zip->new();

    #$zip->addString( $payload, $filename );
    $zip->addFile( $filename, $metadata{'original_filename'} );
    $zip->writeToFileNamed( $dir . $metadata{'zipname'} );

    ################################
    # Upload the ZIP archive to S3 #
    ################################

    # Define where the file will be stored
    $metadata{'full_filepath'} =
      $metadata{'bucketpath'} . "/" . $metadata{'zipname'};

    $bucket->add_key_filename( $metadata{'full_filepath'},
        $dir . $metadata{'zipname'} );

    # Delete the temp ZIP file
    unlink( $dir . $metadata{'zipname'} );

    ###############################
    # Upload metadata to SimpleDB #
    ###############################

    my @attributes = ();

    # Put the metadata hash into an array, just like how SimpleDB wants it
    for my $key ( keys %metadata ) {
        my $value = $metadata{$key};

        @attributes = {
            Name    => $key,
            Value   => $value,
            Replace => ''
        };

        my $response = $simpledb->putAttributes(
            {
                DomainName => $config->{'settings'}->{'simpledb_name'},
                ItemName   => $metadata{'sha256'},
                Attribute  => @attributes
            }
        );

    }

    ########################
    # Create SQS Ticket(s) #
    ########################

    my $sqs = new Amazon::SQS::Simple(
        $config->{'settings'}->{'aws_access_key_id'},
        $config->{'settings'}->{'aws_secret_access_key'}
    );

    my $queues = $config->{queues};
    while ( my ( $queue, $value ) = each(%$queues) ) {
        if ( $value =~ /true/ ) {
            my $queuename = $config->{settings}->{sqs_prefix} . $queue;
            print "DEBUG: Creating SQS Queue: $queuename\n";
            my $q = $sqs->CreateQueue($queuename);
            print "DEBUG: Putting $metadata{'sha256'} into $queuename\n";
            $q->SendMessage( $metadata{'sha256'} );
        }
    }

    #dump_meta;
    #update_wiki;
}

# FIXME: Should be it's own program, grabbing metadata from SimpleDB
sub update_wiki {
    #######################
    # Upload data to Wiki #
    #######################

    print "DEBUG: update_wiki();\n";

    ###############################
    # Setup MediaWiki environment #
    ###############################

    my $mw = CMS::MediaWiki->new(
        host => $config->{'settings'}->{'mediawiki_host'},
        path => $config->{'settings'}->{'mediawiki_path'}
    );

    $mw->login(
        user => $config->{'settings'}->{'mediawiki_username'},
        pass => $config->{'settings'}->{'mediawiki_password'}
    );

    # Download Template page
    my $wiki_text = $mw->getPage( title => 'SampleTemplate' );

    # Create a new page from the template page
    $mw->editPage(
        title   => $metadata{'sha256'},
        text    => $wiki_text,
        summary => "Copied template"
    );

    # Edit the "Sample Information" section
    $wiki_text =
        "== Sample Information ==\n"
      . "\'\'\'Submitted by:\'\'\' "
      . $metadata{'From'}
      . "<br />\n"
      . "\'\'\'Date submitted:\'\'\' "
      . $metadata{'sent_DateTime'}->ymd("-")
      . "<br />\n"
      . "\'\'\'Date received:\'\'\' "
      . $metadata{'rcvd_DateTime'}->ymd("-")
      . "<br />\n"
      . "\'\'\'Original filename:\'\'\' "
      . $metadata{'original_filename'}
      . "<br />\n" . "\n"
      . "\'\'\'MD5  Checksum:\'\'\' "
      . $metadata{'md5'}
      . "<br />\n"
      . "\'\'\'SHA1 Checksum:\'\'\' "
      . $metadata{'sha1'}
      . "<br />\n"
      . "\'\'\'SHA256 Checksum:\'\'\' "
      . $metadata{'sha256'}
      . "<br />\n" . "\n"
      . "=== Sample Download ===\n"
      . "[http://"
      . $config->{'settings'}->{bucketname} . "/"
      . $metadata{'full_filepath'}
      . " Sample is available to verified malware researchers]\n";

    $mw->editPage(
        title   => $metadata{'sha256'},
        section => 'Sample Information',
        text    => $wiki_text,
        summary => "Updated ==Sample Information=="
    );
}

# gets:
#  zipname - exact location (relative/absolute) of zip archive
#  [directory] - directory in which to extract(optional)
# returns:
#  (err(undef == ok), directory, fname)
sub system_unzip {
    my ( $fname, $dir ) = @_;
    if ( !defined($dir) ) {
        $dir = tempdir( CLEANUP => 1 );
    }
    print "DEBUG: system_unzip( " . $fname . ", " . $dir . " );\n";

    my $ziperrlogfile = "ziperrlog-" . rand_string();
    system(
        "unzip -P infected -d \"$dir\" \"$fname\" 2>$ziperrlogfile 1>/dev/null"
    );
    my $error = undef;

    # test for "bad CRC" at unzip
    {
        open my ($hzl), $ziperrlogfile;
        while (<$hzl>) {
            if ( index( $_, "bad CRC" ) >= 0 ) {
                $error = "bad crc";
                last;
            }
        }
        close $hzl;
    }
    if ( $? == -1 ) {
        $error = "failed to execute unzip: $!";
    }
    elsif ( $? & 127 ) {
        printf "child died with signal %d, %s coredump\n", ( $? & 127 ),
          ( $? & 128 ) ? 'with' : 'without';
    }
    else {
        ;    #printf "child exited with value %d\n", $? >> 8;
    }
    unlink $ziperrlogfile;
    my @flist;

    # reading the folder contents
    my $dirh;
    if ( opendir $dirh, $dir ) {
        while ( my $ff = readdir $dirh ) {
            if ( -f "$dir/$ff" ) {
                push @flist, $ff;
            }
        }
        closedir $dirh;
    }
    else {
        $error = "could not opendir($dir)";
    }

    if ( defined($error) ) {
        return ( $error, $dir, undef );
    }
    else {
        return ( undef, $dir, @flist );
    }
}

sub system_unrar {
    my ( $fname, $dir ) = @_;
    if ( !defined($dir) ) {
        $dir = tempdir( CLEANUP => 1 );
    }
    print "DEBUG: system_unrar( " . $fname . ", " . $dir . " );\n";

    my $rarerrlogfile = "rarerrlog-" . rand_string();
    system(
        "unrar -pinfected x \"$fname\"  \"$dir\" 2>$rarerrlogfile 1>/dev/null"
    );
    my $error = undef;

    # test for "bad CRC" at unrar
    {
        open my ($hzl), $rarerrlogfile;
        while (<$hzl>) {
            if ( index( $_, "bad CRC" ) >= 0 ) {
                $error = "bad crc";
                last;
            }
        }
        close $hzl;
    }
    if ( $? == -1 ) {
        $error = "failed to execute unrar: $!";
    }
    elsif ( $? & 127 ) {
        printf "child died with signal %d, %s coredump\n", ( $? & 127 ),
          ( $? & 128 ) ? 'with' : 'without';
    }
    else {
        ;    #printf "child exited with value %d\n", $? >> 8;
    }
    unlink $rarerrlogfile;
    my @flist;

    # reading the folder contents
    my $dirh;
    if ( opendir $dirh, $dir ) {
        while ( my $ff = readdir $dirh ) {
            if ( -f "$dir/$ff" ) {
                push @flist, $ff;
            }
        }
        closedir $dirh;
    }
    else {
        $error = "could not opendir($dir)";
    }

    if ( defined($error) ) {
        return ( $error, $dir, undef );
    }
    else {
        return ( undef, $dir, @flist );
    }
}

sub rand_string {
    my ($len) = @_;
    $len ||= 12;
    print "DEBUG: rand_string( " . $len . " );\n";

    my @chars = ( 'A' .. 'Z', 'a' .. 'z', '0' .. '9' );
    my @r;
    my $l = scalar @chars;
    foreach ( 1 .. $len ) {
        $r[ $_ - 1 ] = $chars[ rand($l) ];
    }
    return join '', @r;
}
