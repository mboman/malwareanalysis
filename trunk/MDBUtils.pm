package MDBUtils;

# Stop us from shooting outselves in the foot
use strict;
use warnings;

# We need to calculate checksums
use Digest::SHA256;
use Digest::SHA1 qw( sha1_hex );
use Digest::MD5::File qw( file_md5_hex );

# We need to handle compression
use Archive::Zip;
use File::Temp qw( tempdir );
use File::Magic;
use File::Spec;
use File::Basename;

sub filetype {
    my $filename = shift or die("FUNCTION USAGE: mdb_filetype( filename );\n");

    my $magic    = File::Magic->new();
    my $filetype = $magic->type($filename);
    return $filetype;
}

#######################
# Extract the archive #
#######################
sub extract_archive_zip {
    my $filename = shift
      or die("FUNCTION USAGE: extract_archive_zip( filename );\n");
    my $tmpdir = tempdir( CLEANUP => 1 );

    # unzip gets very angry if the file doesn't end with 'zip'
    # we solve it by just sticking ".zip" at the end of the file
    my $new_filename = $filename . ".zip";
    rename( $filename, $new_filename );
    $filename = $new_filename;

    my ( $error, $dir, @flist ) = system_unzip($filename);
    my $no_of_files = scalar(@flist);

    # For each attachment in the email...
    for ( my $count = 0 ; $count < $no_of_files ; $count++ ) {
        my $file = File::Spec->catfile( $dir, $flist[$count] );
        process_file($file);
    }
}

#######################
# Extract the archive #
#######################
sub extract_archive_rar {
    my $filename = shift
      or die("FUNCTION USAGE: extract_archive_rar( filename );\n");
    my $tmpdir = tempdir( CLEANUP => 1 );

    # unrar gets very angry if the file doesn't end with 'rar'
    # we solve it by just sticking ".rar" at the end of the file
    my $new_filename = $filename . ".rar";
    rename( $filename, $new_filename );
    $filename = $new_filename;

    my ( $error, $dir, @flist ) = system_unrar($filename);
    my $no_of_files = scalar(@flist);

    my @filelist;

    # For each file in the archive...
    for ( my $count = 0 ; $count < $no_of_files ; $count++ ) {
        my $file = File::Spec->catfile( $dir, $flist[$count] );
	push(@filelist, $file);
    }
    return( @filelist );
}

########################################################
# Helper function. Writes file using string as content #
########################################################
sub string_to_file {
    my ( $filename, $data ) = @_;

    open( OUTFILE, ">$filename" );
    print OUTFILE $data;
    close(OUTFILE);
}

###########################################
# Helper function. Reads file into string #
###########################################
sub file_to_string {
    my $filename = shift
      or die("FUNCTION USAGE: file_to_string( filename );\n");
    my $string;

    open( INFILE, "<$filename" );
    while (<INFILE>) {
        $string = $string . $_;
    }
    close(INFILE);
    return $string;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub mdb_sha256_hex {
    my $filename = shift or die("FUNCTION USAGE: my_sha256_hex( filename );\n");

    my $sha256 = Digest::SHA256::new("256");

    $sha256->reset();
    $sha256->add( file_to_string($filename) );
    my $result = $sha256->hexdigest();    # Calculate SHA256 checksum
    $result =~ s/\ //g;    # Remove the spaces from the SHA256 checksum

    return $result;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub mdb_md5_hex {
    my $filename = shift or die("FUNCTION USAGE: my_md5_hex( filename );\n");

    my $result = file_md5_hex($filename);
    return $result;
}

##########################################################################
# A small helper function so sha256 works the same way sha1 and md5 does #
##########################################################################
sub mdb_sha1_hex {
    my $filename = shift or die("FUNCTION USAGE: my_sha1_hex( filename );\n");

    my $result = sha1_hex( file_to_string($filename) );
    return $result;
}

# gets:
#  zipname - exact location (relative/absolute) of zip archive
#  [directory] - directory in which to extract(optional)
# returns:
#  (err(undef == ok), directory, fname)
sub system_unzip {
    my ( $fname, $dir ) = @_;
    if ( !defined($dir) ) {
        $dir = tempdir( CLEANUP => 1 );
    }

    my $ziperrlogfile = "ziperrlog-" . rand_string();
    system(
        "unzip -P infected -d \"$dir\" \"$fname\" 2>$ziperrlogfile 1>/dev/null"
    );
    my $error = undef;

    # test for "bad CRC" at unzip
    {
        open my ($hzl), $ziperrlogfile;
        while (<$hzl>) {
            if ( index( $_, "bad CRC" ) >= 0 ) {
                $error = "bad crc";
                last;
            }
        }
        close $hzl;
    }
    if ( $? == -1 ) {
        $error = "failed to execute unzip: $!";
    }
    elsif ( $? & 127 ) {
        printf "child died with signal %d, %s coredump\n", ( $? & 127 ),
          ( $? & 128 ) ? 'with' : 'without';
    }
    else {
        ;    #printf "child exited with value %d\n", $? >> 8;
    }
    unlink $ziperrlogfile;
    my @flist;

    # reading the folder contents
    my $dirh;
    if ( opendir $dirh, $dir ) {
        while ( my $ff = readdir $dirh ) {
            if ( -f "$dir/$ff" ) {
                push @flist, $ff;
            }
        }
        closedir $dirh;
    }
    else {
        $error = "could not opendir($dir)";
    }

    if ( defined($error) ) {
        return ( $error, $dir, undef );
    }
    else {
        return ( undef, $dir, @flist );
    }
}

# gets:
#  rarname - exact location (relative/absolute) of zip archive
#  [directory] - directory in which to extract(optional)
# returns:
#  (err(undef == ok), directory, fname)
sub system_unrar {
    my ( $fname, $dir ) = @_;
    if ( !defined($dir) ) {
        $dir = tempdir( CLEANUP => 1 );
    }

    my $rarerrlogfile = "rarerrlog-" . rand_string();
    system(
        "unrar -pinfected x \"$fname\"  \"$dir\" 2>$rarerrlogfile 1>/dev/null"
    );
    my $error = undef;

    # test for "bad CRC" at unrar
    {
        open my ($hzl), $rarerrlogfile;
        while (<$hzl>) {
            if ( index( $_, "bad CRC" ) >= 0 ) {
                $error = "bad crc";
                last;
            }
        }
        close $hzl;
    }
    if ( $? == -1 ) {
        $error = "failed to execute unrar: $!";
    }
    elsif ( $? & 127 ) {
        printf "child died with signal %d, %s coredump\n", ( $? & 127 ),
          ( $? & 128 ) ? 'with' : 'without';
    }
    else {
        ;    #printf "child exited with value %d\n", $? >> 8;
    }
    unlink $rarerrlogfile;
    my @flist;

    # reading the folder contents
    my $dirh;
    if ( opendir $dirh, $dir ) {
        while ( my $ff = readdir $dirh ) {
            if ( -f "$dir/$ff" ) {
                push @flist, $ff;
            }
        }
        closedir $dirh;
    }
    else {
        $error = "could not opendir($dir)";
    }

    if ( defined($error) ) {
        return ( $error, $dir, undef );
    }
    else {
        return ( undef, $dir, @flist );
    }
}

sub rand_string {
    my ($len) = @_;
    $len ||= 12;

    my @chars = ( 'A' .. 'Z', 'a' .. 'z', '0' .. '9' );
    my @r;
    my $l = scalar @chars;
    foreach ( 1 .. $len ) {
        $r[ $_ - 1 ] = $chars[ rand($l) ];
    }
    return join '', @r;
}
1;
